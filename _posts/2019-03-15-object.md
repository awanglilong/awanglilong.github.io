---
layout:     post
title:      "面向对象"
subtitle:   " \"面向对象如何学习\""
date:       2019-3-15 18:53:00
author:     "wanglilong"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
- 面向对象
---
# 面向对象
## 一、三大特性
### 1、封装

>封装是隐藏对象的属性和实现细节，仅对外提供公共访问方式。

**好处**

（1）控制访问：提高代码健壮性。

（2）隔离变化：类内部逻辑变化的影响不会扩散。

（3）降低思维负担：信息更少，更容易被理解和修改。

### 2、继承
>继承实现了 IS-A 关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。

**好处**

（1）继承基类的方法，做出自己的改变和扩展，实现代码复用。

（2）声明某个子类兼容于某基类，外部调用者可无需关注其差别。

**使用问题**

（1）尽量使用继承，多态和大多设计模式的实现都是基于继承。想要掌握面向对象首先要熟练正确使用继承。

（2）不要为实现代码复用，使用继承。

### 3、多态
>多态性是允许你将父对象设置成为一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作.

**好处**

  派生类的功能可以被基类的方法或引用变量所调用，这叫向后兼容，可以提高可扩充性和可维护性

**实现条件**


（1）继承：必须存在有继承关系的子类和父类。

（2）重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。

（3）向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。


### 4、学习三大特性
1、简单了解三大特性定义，以及其实现。

2、在开发中使用三大特性。

3、学习在各个设计模式中，它们是如何使用面向对象三大特性。


## 二、设计原则

### S.O.L.I.D

| 简写 | 全拼 | 中文翻译 |
| :--: | :--: | :--: |
| SRP | The Single Responsibility Principle    | 单一责任原则 |
| OCP | The Open Closed Principle              | 开放封闭原则 |
| LSP | The Liskov Substitution Principle      | 里氏替换原则 |
| ISP | The Interface Segregation Principle    | 接口分离原则 |
| DIP | The Dependency Inversion Principle     | 依赖倒置原则 |

### 1. 单一责任原则

> 修改一个类的原因应该只有一个。

换句话说就是让一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类。

如果一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责的变化可能会削弱这个类完成其它职责的能力。

### 2. 开放封闭原则

> 类应该对扩展开放，对修改关闭。

扩展就是添加新功能的意思，因此该原则要求在添加新功能时不需要修改代码。

符合开闭原则最典型的设计模式是装饰者模式，它可以动态地将责任附加到对象上，而不用去修改类的代码。

### 3. 里氏替换原则

> 子类对象必须能够替换掉所有父类对象。

继承是一种 IS-A 关系，子类需要能够当成父类来使用，并且需要比父类更特殊。

如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。

### 4. 接口分离原则

> 不应该强迫客户依赖于它们不用的方法。

因此使用多个专门的接口比使用单一的总接口要好。

### 5. 依赖倒置原则

> 高层模块不应该依赖于低层模块，二者都应该依赖于抽象；</br>抽象不应该依赖于细节，细节应该依赖于抽象。

高层模块包含一个应用程序中重要的策略选择和业务模块，如果高层模块依赖于低层模块，那么低层模块的改动就会直接影响到高层模块，从而迫使高层模块也需要改动。

依赖于抽象意味着：

- 任何变量都不应该持有一个指向具体类的指针或者引用；
- 任何类都不应该从具体类派生；
- 任何方法都不应该覆写它的任何基类中的已经实现的方法。

### 其他常见原则
除了上述的经典原则，在实际开发中还有下面这些常见的设计原则。

| 简写    | 全拼    | 中文翻译 |
| :--: | :--: | :--: |
|LOD|    The Law of Demeter                   | 迪米特法则   |
|CRP|    The Composite Reuse Principle        | 合成复用原则 |

#### 1. 迪米特法则

迪米特法则又叫作最少知识原则（Least Knowledge Principle，简写 LKP），就是说一个对象应当对其他对象有尽可能少的了解，不和陌生人说话。

#### 2. 合成复用原则

尽量使用对象组合，而不是通过继承来达到复用的目的。

#### 3.对接口编程而不是对实现编程
继承应当继承接口，而不是具体实现。

#### 4.松耦合设计


>注释：设计的原则的学习，应该在设计模式中仔细体会他们的体现形式。

## 三、类图
以下类图使用 [PlantUML](https://www.planttext.com/) 绘制。

### 泛化关系 (Generalization)

用来描述继承关系，在 Java 中使用 extends 关键字。

<div align="center"> <img src="/img/post-object/SoWkIImgAStDuU8goIp9ILLmJyrBBKh.png"/> </div><br>

注：最终代码中，泛化关系表现为继承非抽象类；


### 实现关系 (Realization)

用来实现一个接口，在 Java 中使用 implements 关键字。

<div align="center"> <img src="/img/post-object/SoWkIImgAStDuU8goIp9ILK8IatCoQn.png"/> </div><br>

注：最终代码中，实现关系表现为继承抽象类；

### 聚合关系 (Aggregation)

表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。

<div align="center"> <img src="/img/post-object/SoWkIImgAStDuU8goIp9ILLmJ4ylIar.png"/> </div><br>

### 组合关系 (Composition)

和聚合不同，组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了。但是公司和员工就属于聚合关系了，因为公司没了员工还在。

<div align="center"> <img src="/img/post-object/SoWkIImgAStDuU8goIp9ILLmpiyjo2_.png"/> </div><br>


### 关联关系 (Association)

表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示。比如学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。

<div align="center"> <img src="/img/post-object/SoWkIImgAStDuU8goIp9ILLmB2xEJyv.png"/> </div><br>

注：在最终代码中，关联对象通常是以成员变量的形式实现的；

### 依赖关系 (Dependency)

和关联关系不同的是，依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有三种形式：**（属性）**

- A 类是 B 类方法的局部变量；
- A 类是 B 类方法当中的一个参数；
- A 类向 B 类发送消息，从而影响 B 类发生变化。

<div align="center"> <img src="LOun2W9134NxVugmbJPp15d4LalxC4O.png"/> </div><br>

注：在最终代码中，依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系；依赖关系除了临时知道对方外，还是“使用”对方的方法和属性；

参考

[面向对象思想](https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/面向对象思想.md)
